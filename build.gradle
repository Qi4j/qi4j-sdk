
project.ext {
  title = "Qi4j SDK"
  description = "Qi4jâ„¢ is a framework for domain centric application development, including evolved concepts from AOP, DI and DDD."
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'signing'
apply from: 'maven-compat.gradle'
apply plugin: 'project-report'
apply from: 'libraries.gradle'

targetCompatibility = "1.6"
sourceCompatibility = "1.6"

project.ext {
    testFailures = [ ]
    mainClassName = 'org.qi4j.container.Main'
    groovycMain_mx = "512m"
    groovycMain_permSize = "64m"
    groovycMain_maxPermSize = "128m"
}


// Collect the modules that fulfills the Release Criteria.
project.ext {
  releaseSpec = new ModuleReleaseSpecification()
}

def releaseApprovedProjects = allprojects.findAll( { project ->  rootProject.ext.releaseSpec.satisfiedBy( project ) } )

buildscript {
  repositories {
    mavenCentral()
  }
}

idea.project.ipr {
  withXml { provider ->
    provider.node.component.find { it.@name == 'VcsDirectoryMappings' }.mapping.@vcs = 'Git'
  }
}


allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'signing'
  apply plugin: 'java'
  apply plugin: 'checkstyle'
  apply plugin: 'project-report'
  dependsOnChildren()

  defaultTasks 'classes', 'test'

  group = name.substring( 0, name.lastIndexOf( '.' ) )
  version = System.properties.version ?: "0"
  [ compileJava, compileTestJava ]*.options*.encoding = 'UTF-8'

  repositories {
    mavenCentral()
    mavenRepo name: 'ops4j-repo', url: "http://repository.ops4j.org/maven2/"
    mavenRepo name: 'aduna-repo', url: "http://repo.aduna-software.org/maven2/releases/"
    mavenRepo name: 'restlet-repo', url: 'http://maven.restlet.org'
    mavenRepo name: 'maven2-repository.dev.java.net', url: "http://download.java.net/maven/2"
  }

  configurations {
    deployerJars
    provided
    compile.extendsFrom provided
  }

  dependencies {
    testCompile( libraries.ant )
    testCompile( libraries.ant_junit )
    testCompile( libraries.junit )
    testRuntime( libraries.asm, libraries.asm_commons, libraries.asm_util )
    deployerJars "org.apache.maven.wagon:wagon-ssh:1.0-beta-2"
  }

  sourceSets {
    docs {
      resources {
        srcDir 'src/docs'
      }
    }
  }

  test.onlyIf { !project.hasProperty( 'skipTests' ) }

  project.ext {
    javaDir = new File( "$projectDir/src/main/java" )
    documenationDir = new File( "$projectDir/src/docs" )
    testDir = new File( "$projectDir/src/tests/java" )
  }

  if( ext.documenationDir.isDirectory() )
  {
    task docsJar( type: Jar ) {
      classifier = "docs"
      from sourceSets.docs.resources
    }
    artifacts {
      archives docsJar
    }
  }

  if( ext.javaDir.isDirectory() || ext.testDir.isDirectory() )
  {
    apply plugin: 'osgi'
    apply plugin: VersionClass

    if( name == "org.qi4j.core.runtime" )
    {
      checkstyleMain {
        configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-runtime-checkstyle.xml" )
        ignoreFailures = true
      }
    }
    else
    {
      checkstyleMain {
        configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-api-checkstyle.xml" )
        ignoreFailures = true
      }
    }
    checkstyleTest {
      configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml" )
      ignoreFailures = true
    }

    checkstyleVersion {
      configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml" )
      ignoreFailures = true
    }

    jar {
      manifest {
        license = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        docURL = 'http://www.qi4j.org'
        description = project.description ?: 'Qi4j is a platform for Composite Oriented Programming'
        vendor = 'Qi4j Community, http://www.qi4j.org'
        instruction '-debug', 'true'
      }
    }

    signing {
      sign configurations.archives
    }

    task sourceJar( type: Jar ) {
      classifier = "sources"
      from sourceSets.main.allSource
    }

    task testSourceJar( type: Jar ) {
      classifier = "testsources"
      from sourceSets.test.allSource
    }

    task javadocJar( type: Jar ) {
      classifier = "javadoc"
      from javadoc.destinationDir
      dependsOn javadoc
    }

    artifacts {
      archives sourceJar, testSourceJar, javadocJar
    }

    def testProperties = [
            'proxySet': System.properties[ 'proxySet' ],
            'proxyHost': System.properties[ 'proxyHost' ],
            'proxyPort': System.properties[ 'proxyPort' ] ]

    test {
      maxHeapSize = "1024m"
      systemProperties = testProperties
      ignoreFailures = true
      afterSuite { descriptor, result ->
        if( result.resultType == TestResult.ResultType.FAILURE )
        {
          rootProject.ext.testFailures = project
        }
      }
    }

    // Create checkstyle report
    task checkstyleReport( type: Xslt, dependsOn: check ) {
      source project.checkstyle.reportsDir
      include '*.xml'
      destDir = file( "build/reports/checkstyle/" )
      extension = 'html'
      stylesheetFile = file( "$rootProject.projectDir/etc/checkstyle-noframes.xsl" )
    }

    task minBuild {
      dependsOn classes
      dependsOn test
    }
  }

  task createDependencyList << {
    def depList = ""
    configurations.runtime.each { file ->
      if( !file.name.startsWith( "org.qi4j.core" ) )
      {
        depList = depList + "$file.name\n"
      }
    }
    def destFile = new File( buildDir, "downloads.sh" )
    destFile.text = depList
  }

  uploadArchives.doFirst {
    if( version == 0 )
    {
      throw new GradleException( "'version' must be given as a system property to perform a release." )
    }
  }

  uploadArchives.onlyIf { ( releaseApprovedProjects.contains( project ) || project == rootProject ) && !project.hasProperty( 'skipUpload' ) }
  uploadArchives {
    dependsOn check
    repositories.mavenDeployer {
      beforeDeployment { MavenDeployment deployment -> signPom( deployment ) }
      name = 'sshDeployer' // optional
      configuration = configurations.deployerJars
      repository( url: "scp://repository.ops4j.org/home/www/repository.ops4j.org/maven2/" )
    }
  }

  idea.module.iml {
    whenMerged { module ->
      module.dependencies*.exported = true
    }
  }
}

gradle.taskGraph.whenReady {taskGraph ->
  taskGraph.allTasks.last().doLast {
    if( rootProject.ext.testFailures )
    {
      println "\nTest failures in:"
      rootProject.ext.testFailures.each { project -> println "  " + project.name }
      throw new RuntimeException( "There was TEST FAILURES!! See list above." )
    }
  }
}

test.doLast() {
  ant {
    taskdef( name: 'junitreport',
             classname: 'org.apache.tools.ant.taskdefs.optional.junit.XMLResultAggregator',
             classpath: configurations.testRuntime.asPath )

    // create Junit report
    def junitReportDir = "$buildDir/reports/junit"
    mkdir( dir: junitReportDir )
    mkdir( dir: "$buildDir/test-results" )
    junitreport( todir: junitReportDir ) {
      report( format: 'frames', todir: junitReportDir )
      allprojects.each { module ->
        fileset( dir: "$module.buildDir/test-results" ) {
          include( name: "TEST-*.xml" )
        }
      }
    }

  }
}

task javadocs( type: Javadoc ) {
  dependsOn allprojects*.javadoc

  options.docFilesSubDirs = true
  title = "${rootProject.title} ${version}"
  def apiSources = releaseApprovedProjects.findAll( { project ->
    ( project.name.startsWith( 'org.qi4j.core' ) &&
      !project.name.startsWith( 'org.qi4j.core.runtime' ) ) ||
    project.name.startsWith( 'org.qi4j.library' ) ||
    project.name.startsWith( 'org.qi4j.extension' )
  } )
  source apiSources.collect { project ->
    project.sourceSets.main.allJava
  }
  destinationDir = new File( "$buildDir/docs/javadoc" )
  // Might need a classpath
  classpath = files( apiSources.collect { project ->
    project.sourceSets.main.compileClasspath
  } )
  options.links( "http://java.sun.com/j2se/1.6.0/docs/api" )
  options.group( [ "Core API": [ "org.qi4j.api", "org.qi4j.api.*" ],
                         "Core Bootstrap": [ "org.qi4j.bootstrap" ],
                         "Core SPI": [ "org.qi4j.spi", "org.qi4j.spi.*" ],
                         "Libraries": [ "org.qi4j.library.*", "org.qi4j.logging", "org.qi4j.logging.*", "org.qi4j.scripting.*" ],
                         "Extensions": [ "org.qi4j.entitystore.*", "org.qi4j.index.*", "org.qi4j.cache.*", "org.qi4j.migration", "org.qi4j.migration.*" ],
                         "Test Support": [ "org.qi4j.test", "org.qi4j.test.*" ]
                 ] )

}

task distLayout( dependsOn: [ javadocs, test, jar, subprojects*.build, ':org.qi4j.manual:manuals' ] ) {

  srcDistImage = copySpec {
    from '.'
    exclude '**/build/'     // build output
    exclude '**/bin/'       // helper scripts
    exclude '**/out/'       // build output
    exclude '**/.git/'      // git directories
    exclude '**/.git*'      // git files
    exclude '**/.gradle/'   // gradle management files
    into "qi4j-sdk-$version/src/"
  }

  docsImage = copySpec {
    from "$buildDir/docs"
    into( "docs" )
  }

  manualsImage = copySpec {
    from "manual/$buildDir/docs"
    into( "docs/manual" )
  }

  reportsImage = copySpec {
    from "$buildDir/reports"
    into( "docs/reports" )
  }

  downloadListImage = copySpec {
    releaseApprovedProjects.collect { proj ->
      from "$proj.buildDir/downloads.sh"
      into( "libs/downsloads/dl-$proj.name" )
    }
  }

  libsImage = copySpec {
    releaseApprovedProjects.collect { proj ->
      into( "libs/" ) {
        from proj.configurations.archives
      }
    }
  }

  samplesImage = copySpec {
    from( "$projectDir/samples" ) {
      into( "samples" )
      exclude '**/build/**'
    }
    from( "$projectDir/samples/*/build/docs/javadoc" ) {
      into( "samples/docs" )
    }
    exclude '**/*.iml'
  }

  tutorialsImage = copySpec {
    from( "$projectDir/tutorials" ) {
      exclude '**/build/**'
      into( "tutorials" )
    }
    from( "$projectDir/tutorials/*/build/docs/javadoc" ) {
      into( "tutorials/docs" )
    }
    exclude '**/*.iml'
  }

  binDistImage = copySpec {
    into "qi4j-sdk-$version"
    with docsImage
    with downloadListImage
    with libsImage
    with samplesImage
    with tutorialsImage
  }

  siteDocDistImage = copySpec {
    into "qi4j/$version"
    with docsImage
    with reportsImage
    with samplesImage
    with tutorialsImage
  }
}

task zipSources( type: Zip, dependsOn: distLayout ) {
  baseName = 'qi4j-sdk'
  with distLayout.srcDistImage
  classifier = 'src'
}

task tarSources( type: Tar, dependsOn: distLayout ) {
  baseName = 'qi4j-sdk'
  with distLayout.srcDistImage
  compression = Compression.GZIP
  classifier = 'src'
}

task zipBinaries( type: Zip, dependsOn: distLayout ) {
  baseName = 'qi4j-sdk'
  classifier = 'bin'
  with distLayout.binDistImage
}

task tarBinaries( type: Tar, dependsOn: distLayout ) {
  baseName = 'qi4j-sdk'
  classifier = 'bin'
  compression = Compression.GZIP
  with distLayout.binDistImage
}

task zipSiteDoc( type: Zip, dependsOn: distLayout ) {
  baseName = 'qi4j-sdk'
  classifier = 'site'
  with distLayout.siteDocDistImage
}

task tarSiteDoc( type: Tar, dependsOn: distLayout ) {
  baseName = 'qi4j-sdk'
  classifier = 'site'
  compression = Compression.GZIP
  with distLayout.siteDocDistImage
}

artifacts {
  archives zipSources, tarSources, zipBinaries, tarBinaries, zipSiteDoc, tarSiteDoc
}

task dist( type: Copy, dependsOn: [ zipBinaries, tarBinaries, tarSources, zipSources ] ) {
  with distLayout.binDistImage
  into "$buildDir/dist"
}

task release {
  description = 'Builds, tests and uploads the release artifacts'
  group = 'release'
  doFirst {
    if( System.properties[ 'version' ] == null )
    {
      throw new GradleException( "'version' must be given as a system property to perform a release." )
    }
  }
  dependsOn allprojects*.uploadArchives
}

//
// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting ouput committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper( type: Wrapper ) {
  gradleVersion = '1.0-rc-3'
}
